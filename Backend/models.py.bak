"""
Backup of original Backend/models.py before replacing with models_from_db-derived models.
"""
from django.db import models
from django.conf import settings
from django.contrib.auth.models import AbstractUser


class Zona(models.Model):
    nombre = models.CharField(max_length=100, unique=True)
    descripcion = models.TextField(blank=True, null=True)
    # Map to the Spanish table column 'perimetro_geografico'. We assume it stores GeoJSON-like data
    # or a textual representation; use JSONField to be tolerant. If this is a PostGIS geometry type,
    # further adjustments (GeoDjango) will be needed.
    geometria = models.JSONField(null=True, blank=True, db_column='perimetro_geografico')
    fecha_creacion = models.DateTimeField(null=True, blank=True, db_column='fecha_creacion')
    fecha_actualizacion = models.DateTimeField(null=True, blank=True, db_column='fecha_actualizacion')

    class Meta:
        db_table = 'zona'
        managed = False

    def __str__(self):
        return self.nombre


class UserProfile(models.Model):
    ROLE_CHOICES = [
        ('admin', 'Administrador'),
        ('user', 'Usuario'),
        ('moderator', 'Moderador'),
    ]

    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='profile')
    role = models.CharField(max_length=20, choices=ROLE_CHOICES, default='user')
    telefono = models.CharField(max_length=30, blank=True)

    def __str__(self):
        return f"{self.user.get_full_name() or self.user.username} ({self.role})"

    class Meta:
        # keep original table for Django-managed profiles; do not map to the Spanish `usuario` table automatically
        # to avoid colliding with an existing custom userzz table. If you want to use the `usuario` table instead,
        # we can add a separate `Usuario` model mapped to that table.
        db_table = 'Backend_userprofile'
        managed = True


class TipoRiesgo(models.Model):
    nombre = models.CharField(max_length=200)
    descripcion = models.TextField(null=True, blank=True)
    nivel_prioridad = models.CharField(max_length=50)
    fecha_creacion = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = 'tipo_riesgo'
        managed = False

    def __str__(self):
        return self.nombre


class Reporte(models.Model):
    # Map core columns from the existing 'reporte' table.
    ubicacion = models.CharField(max_length=255, db_column='ubicacion')
    latitud = models.DecimalField(max_digits=10, decimal_places=6, null=True, blank=True, db_column='latitud')
    longitud = models.DecimalField(max_digits=10, decimal_places=6, null=True, blank=True, db_column='longitud')
    ubicacion_geoespacial = models.JSONField(null=True, blank=True, db_column='ubicacion_geoespacial')
    # Zona foreign key (points to `zona.id`)
    zona = models.ForeignKey(Zona, on_delete=models.SET_NULL, null=True, blank=True, db_column='zona_id', related_name='reportes')
    # tipo_riesgo and estado are stored as FK ids in the existing table; map them to simple fields or FKs where available
    tipo_riesgo = models.ForeignKey(TipoRiesgo, on_delete=models.SET_NULL, null=True, blank=True, db_column='tipo_riesgo_id')
    estado_reporte_id = models.IntegerField(null=True, blank=True, db_column='estado_reporte_id')
    descripcion = models.TextField(db_column='descripcion')
    # usuario_creador_id likely references a custom usuario table; to avoid coupling with auth_user we'll store as integer id
    usuario_creador_id = models.IntegerField(null=True, blank=True, db_column='usuario_creador_id')
    usuario_validador_id = models.IntegerField(null=True, blank=True, db_column='usuario_validador_id')
    fecha_creacion = models.DateTimeField(null=True, blank=True, db_column='fecha_creacion')
    fecha_actualizacion = models.DateTimeField(null=True, blank=True, db_column='fecha_actualizacion')

    class Meta:
        db_table = 'reporte'
        managed = False

    def __str__(self):
        return f"Reporte #{self.pk} - {self.ubicacion}"


class Comentario(models.Model):
    reporte = models.ForeignKey(Reporte, on_delete=models.CASCADE, related_name='comentarios', db_column='reporte_id')
    usuario_id = models.IntegerField(null=True, blank=True, db_column='usuario_id')
    contenido = models.TextField(db_column='contenido')
    fecha_comentario = models.DateTimeField(null=True, blank=True, db_column='fecha_comentario')
    fecha_actualizacion = models.DateTimeField(null=True, blank=True, db_column='fecha_actualizacion')

    class Meta:
        db_table = 'comentario'
        managed = False

    def __str__(self):
        return f"Comentario #{self.pk} en reporte {self.reporte_id}"


class Multimedia(models.Model):
    reporte_id = models.IntegerField(db_column='reporte_id')
    usuario_creador_id = models.IntegerField(db_column='usuario_creador_id')
    ruta_archivo = models.CharField(max_length=512, db_column='ruta_archivo')
    tipo_archivo = models.CharField(max_length=100, db_column='tipo_archivo')
    descripcion = models.TextField(null=True, blank=True, db_column='descripcion')
    fecha_creacion = models.DateTimeField(null=True, blank=True, db_column='fecha_creacion')

    class Meta:
        db_table = 'multimedia'
        managed = False

    def __str__(self):
        return f"Multimedia #{self.pk} (reporte {self.reporte_id})"


class Rol(models.Model):
    nombre = models.CharField(max_length=200)
    descripcion = models.CharField(max_length=300, null=True, blank=True)
    fecha_creacion = models.DateTimeField(null=True, blank=True)
    fecha_actualizacion = models.DateTimeField(null=True, blank=True)

    class Meta:
        db_table = 'rol'
        managed = False

    def __str__(self):
        return self.nombre


class ValidacionReporte(models.Model):
    reporte = models.ForeignKey(Reporte, on_delete=models.CASCADE, db_column='reporte_id')
    usuario_validador_id = models.IntegerField(db_column='usuario_validador_id')
    decision = models.CharField(max_length=50, null=True, blank=True, db_column='decision')
    comentario_validacion = models.TextField(null=True, blank=True, db_column='comentario_validacion')
    fecha_validacion = models.DateTimeField(null=True, blank=True, db_column='fecha_validacion')
    fecha_actualizacion = models.DateTimeField(null=True, blank=True, db_column='fecha_actualizacion')

    class Meta:
        db_table = 'validacion_reporte'
        managed = False

    def __str__(self):
        return f"Validacion #{self.pk} sobre reporte {self.reporte_id}"
